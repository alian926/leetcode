/**
 * 
我们正在玩一个猜数游戏，游戏规则如下：

我从 1 到 n 之间选择一个数字。
你来猜我选了哪个数字。
如果你猜到正确的数字，就会 赢得游戏 。
如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。
每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。
给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。

 

示例 1：


输入：n = 10
输出：16
解释：制胜策略如下：
- 数字范围是 [1,10] 。你先猜测数字为 7 。
    - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $7 。
    - 如果我的数字更大，则下一步需要猜测的数字范围是 [8,10] 。你可以猜测数字为 9 。
        - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $9 。
        - 如果我的数字更大，那么这个数字一定是 10 。你猜测数字为 10 并赢得游戏，总费用为 $7 + $9 = $16 。
        - 如果我的数字更小，那么这个数字一定是 8 。你猜测数字为 8 并赢得游戏，总费用为 $7 + $9 = $16 。
    - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,6] 。你可以猜测数字为 3 。
        - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $3 。
        - 如果我的数字更大，则下一步需要猜测的数字范围是 [4,6] 。你可以猜测数字为 5 。
            - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $5 。
            - 如果我的数字更大，那么这个数字一定是 6 。你猜测数字为 6 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。
            - 如果我的数字更小，那么这个数字一定是 4 。你猜测数字为 4 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。
        - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,2] 。你可以猜测数字为 1 。
            - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $1 。
            - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $7 + $3 + $1 = $11 。
在最糟糕的情况下，你需要支付 $16 。因此，你只需要 $16 就可以确保自己赢得游戏。
示例 2：

输入：n = 1
输出：0
解释：只有一个可能的数字，所以你可以直接猜 1 并赢得游戏，无需支付任何费用。
示例 3：

输入：n = 2
输出：1
解释：有两个可能的数字 1 和 2 。
- 你可以先猜 1 。
    - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $1 。
    - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $1 。
最糟糕的情况下，你需要支付 $1 。
 

提示：

1 <= n <= 200
 */
/**
 * @param {number} n
 * @return {number}
 */
// 动态规划, 将大规模问题拆解成小规模的问题
// 题解: https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/solution/cai-shu-zi-da-xiao-ii-by-leetcode-soluti-a7vg/
var getMoneyAmount = function (n) {
    // 取值 1~n 忽略0处的值, 构建n+1的二维数组
    // f[i][j]表示在范围 [i,j] 内确保胜利的最少金额，目标是计算f(1,n)
    const f = new Array(n + 1).fill(0).map(() => new Array(n + 1).fill(0));

    // 由于状态转移方程为根据规模小的子问题计算规模大的子问题，因此计算子问题的顺序为先计算规模小的子问题，后计算规模大的子问题
    // 逆序求解
    for (let i = n - 1; i >= 1; i--) {
        for (let j = i + 1; j <= n; j++) {
            // 状态转移方程 f(i,j) = min(k + max(f(i, k-1), f(k+1, j))) ,其中i<=k<=j
            // 为了避免出现k+1下标越界，计算 f[i][j] 的方法是：首先令 f[i][j] = j + f[i][j - 1](相等于最大值的情况 如从1~5猜1~6多加了6块钱)，然后遍历 i <= k < j 的每个 k，更新 f[i][j] 的值。
            f[i][j] = j + f[i][j - 1];

            for (let k = i; k < j; k++) {
                // 猜测数字x猜错时,如果x大于所选数字,还要支付金额是f(1, x-1),x小于所选数字时,还要支付金额f(x+1, n)
                // Math.max(f[i][k - 1], f[k + 1][j]) 为 确保获胜
                // Math.min(f[i][j],~~~) 最小现金数
                f[i][j] = Math.min(
                    f[i][j],
                    k + Math.max(f[i][k - 1], f[k + 1][j])
                );
            }
        }
    }
    return f[1][n];
};

var getMoneyAmount = function (n) {
    // 1~n
    const ans = new Array(n + 1).fill(0).map(() => new Array(n + 1).fill(0));

    for (let i = n - 1; i >= 1; i--) {
        for (let j = i + 1; j <= n; j++) {
            ans[i][j] = j + ans[i][j - 1];
            for (let k = i; k < j; k++) {
                ans[i][j] = Math.min(ans[i][j], k+Math.max(ans[i][k - 1], ans[k + 1][j]));
            }
        }
    }

    return ans[1][n];
};

var getMoneyAmount = function (n) {
    const cache = new Array(n + 1).fill(0).map(() => new Array(n + 1).fill(0));
    const dfs = ( l,  r) =>  {
        if (l >= r) return 0;
        if (cache[l][r] != 0) return cache[l][r];
        let ans = Infinity;
        for (let x = l; x <= r; x++) {
            // 当选择的数位 x 时，至少需要 cur 才能猜中数字
            let cur = Math.max(dfs(l, x - 1), dfs(x + 1, r)) + x;
            // 在所有我们可以决策的数值之间取最优
            ans = Math.min(ans, cur);
        }
        cache[l][r] = ans;
        return ans;
    }
    return dfs(1, n);
}


console.log(getMoneyAmount(10))